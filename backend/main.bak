import os
from datetime import date
from fastapi import FastAPI, Depends
from fastapi import HTTPException # Necesitas importar HTTPException
from sqlalchemy import select # Necesitas importar select

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, DeclarativeBase, Mapped, mapped_column
from sqlalchemy import Column, Integer, String, text, update, select, delete, func
from sqlalchemy import Date, ForeignKey, Text
from sqlalchemy.orm import relationship
from sqlalchemy.orm import selectinload
from pydantic import BaseModel, Field
from typing import Optional

from sqlalchemy.orm import joinedload # Asegúrate de que joinedload esté importado
from fastapi import Depends, APIRouter, status # Asegúrate de que status esté importado

# --- PYDANTIC SCHEMAS (API Input/Output) --------------------------------------------------------------------------------

# Esquema para crear un nuevo cliente (Input)
class ClienteCreate(BaseModel):
    nombre: str = Field(..., max_length=255)
    direccion: Optional[str] = Field(None, max_length=255)
    localidad: Optional[str] = Field(None, max_length=100)
    telefono: Optional[str] = Field(None, max_length=50)

# Esquema para el retorno de datos (Output)
class Cliente(ClienteCreate):
    cliente_id: int

    class Config:
        from_attributes = True # Permite mapear desde el objeto ORM ClienteORM

class PaginatedClientes(BaseModel):
    """Esquema de respuesta para búsquedas y paginación."""
    total_registros: int
    clientes: list[Cliente]
    pagina_actual: int
    tamanio_pagina: int

# --- PYDANTIC SCHEMAS (Pedidos) ---

# Input: Lo que el frontend envía para crear un pedido
class PedidoCreate(BaseModel):
    cliente_id: int = Field(..., description="ID del cliente que realiza el pedido.")
    fecha_entrega_estimada: Optional[date] = None
    detalle: Optional[str] = None
    observaciones: Optional[str] = None

# Output: Lo que la API devuelve
class Pedido(PedidoCreate):
    pedido_id: int
    numero_pedido_externo: str
    fecha: date 
    cliente: "Cliente"

    class Config:
        from_attributes = True

class PaginatedPedidos(BaseModel):
    """Esquema de respuesta para búsquedas y paginación de Pedidos."""
    total_registros: int
    pedidos: list[Pedido]  # Reutiliza el schema 'Pedido'
    pagina_actual: int
    tamanio_pagina: int


# Esquema para la actualización (Input para el método PUT)
class PedidoUpdate(BaseModel):
    fecha_entrega_estimada: Optional[date] = None
    detalle: Optional[str] = None
    observaciones: Optional[str] = None


# backend/main.py - Sección PYDANTIC SCHEMAS

class ProductoBase(BaseModel):
    nombre: str = Field(..., max_length=100)

class ProductoCreate(ProductoBase):
    pass

class Producto(ProductoBase):
    producto_id: int
    class Config:
        from_attributes = True



# backend/main.py - Sección PYDANTIC SCHEMAS

class PuestoTrabajoBase(BaseModel):
    nombre: str = Field(..., max_length=100)
    descripcion: Optional[str] = None # Nuevo campo

class PuestoTrabajoCreate(PuestoTrabajoBase):
    pass # Hereda nombre y descripción

class PuestoTrabajo(PuestoTrabajoBase):
    puesto_trabajo_id: int
    class Config:
        from_attributes = True

class PuestoTrabajoUpdate(BaseModel):
    nombre: Optional[str] = None
    descripcion: Optional[str] = None 


# Input: Crea una OP
class OPCreate(BaseModel):
    pedido_id: Optional[int] = Field(None, description="ID del pedido de cliente, si aplica.")
    fecha_estimada_entrega: Optional[date] = None
    detalle: Optional[str] = None
    observaciones: Optional[str] = None

# Input: Actualiza una OP (todos los campos opcionales)
class OPUpdate(BaseModel):
    fecha_estimada_entrega: Optional[date] = None
    detalle: Optional[str] = None
    observaciones: Optional[str] = None

# Output: Respuesta de la OP
class OP(OPCreate):
    op_id: int
    numero_op_externo: str
    fecha: date
    
    # Anida el pedido completo (con cliente anidado)
    pedido: Optional["Pedido"] = None 

    class Config:
        from_attributes = True

# Output: Respuesta paginada
class PaginatedOP(BaseModel):
    total_registros: int
    ops: list[OP]
    pagina_actual: int
    tamanio_pagina: int




# backend/main.py - Sección PYDANTIC SCHEMAS

# Esquema de un Paso individual (Detalle)
class RutaDetalleBase(BaseModel):
    puesto_id: int = Field(..., description="ID del Puesto de Trabajo donde se realiza el paso.")
    secuencia: int = Field(..., ge=1, description="Orden secuencial del paso dentro de la ruta.")

class RutaDetalle(RutaDetalleBase):
    detalle_id: int
    ruta_id: int
    puesto_trabajo: "PuestoTrabajo" # Anidamos el objeto completo del Puesto
    
    class Config:
        from_attributes = True

# Esquema para la Ruta Maestra (CREATE)
class RutaMaestraCreate(BaseModel):
    nombre_ruta: str = Field(..., max_length=100)
    producto_id: int
    # CLAVE: La lista de pasos que se crean junto con la ruta
    pasos: list[RutaDetalleBase] 

# Esquema para la Ruta Maestra (OUTPUT)
class RutaMaestra(BaseModel):
    ruta_id: int
    nombre_ruta: str
    producto_id: int
    producto: "Producto" # Anidamos el objeto Producto completo
    pasos: list[RutaDetalle] # Devolvemos el detalle completo con Puesto de Trabajo anidado

    class Config:
        from_attributes = True


# --- CONFIGURACIÓN DE BASE DE DATOS --------------------------------------------------------------------------

# 1. Recuperar Variables de Entorno (de docker-compose.yml)
DB_HOST = os.getenv("DB_HOST", "db")
DB_NAME = os.getenv("DB_NAME", "federici")
DB_USER = os.getenv("DB_USER", "jnegrete")
DB_PASS = os.getenv("DB_PASS", "IntiMayu") # ¡VERIFICA ESTA CONTRASEÑA!
DB_PORT = os.getenv("DB_PORT", "5432")

# 2. Definir la URL de Conexión (usando asyncpg driver)
DATABASE_URL = (
    f"postgresql+asyncpg://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
)

# 3. Configuración del Motor y Sesión Asíncrona
engine = create_async_engine(
    DATABASE_URL,
    echo=True, # Útil para ver las consultas SQL generadas en los logs de Docker
)

AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# 4. Dependency para obtener la sesión de DB
async def get_db_session():
    """Proporciona una sesión de DB asíncrona a la API."""
    async with AsyncSessionLocal() as session:
        yield session

# --- MODELOS ORM (SQLAlchemy) ----------------------------------------------------------------------------------------

# Clase base para todos los modelos declarativos
class Base(DeclarativeBase):
    pass

# Modelo para la tabla 'numeradores'
class Numerador(Base):
    __tablename__ = "numeradores"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    ultimo_pedido: Mapped[int] = mapped_column(default=0)
    ultima_op: Mapped[int] = mapped_column(default=0)



# Modelo para la tabla 'clientes'
class ClienteORM(Base):
    __tablename__ = "clientes"
    
    cliente_id: Mapped[int] = mapped_column(primary_key=True)
    nombre: Mapped[str] = mapped_column(String(255))
    direccion: Mapped[Optional[str]] = mapped_column(String(255))
    localidad: Mapped[Optional[str]] = mapped_column(String(100))
    telefono: Mapped[Optional[str]] = mapped_column(String(50))


# --- MODELOS ORM (Pedidos) ---


class PedidoORM(Base):
    __tablename__ = "pedidos"
    
    pedido_id: Mapped[int] = mapped_column(primary_key=True)
    numero_pedido_externo: Mapped[str] = mapped_column(String(50), unique=True)
    fecha: Mapped[date] = mapped_column(Date,
                                        server_default=text("CURRENT_DATE")
                                        )
    
    # Clave Foránea
    cliente_id: Mapped[int] = mapped_column(ForeignKey("clientes.cliente_id"))
    
    fecha_entrega_estimada: Mapped[Optional[date]] = mapped_column(Date)
    detalle: Mapped[Optional[str]] = mapped_column(Text) # Usamos Text para campos largos
    observaciones: Mapped[Optional[str]] = mapped_column(Text)
    
    # Relación para facilitar la consulta del nombre del cliente desde el pedido (Opcional, pero útil)
    cliente: Mapped["ClienteORM"] = relationship(backref="pedidos")




class OpORM(Base):
    __tablename__ = "op"
    
    op_id: Mapped[int] = mapped_column(primary_key=True)
    numero_op_externo: Mapped[str] = mapped_column(String(50), unique=True)
    fecha: Mapped[date] = mapped_column(Date, server_default=text("CURRENT_DATE"))
    
    # Clave Foránea: Puede ser NULL (pedidos internos)
    pedido_id: Mapped[Optional[int]] = mapped_column(ForeignKey("pedidos.pedido_id"))
    
    fecha_estimada_entrega: Mapped[Optional[date]] = mapped_column(Date)
    detalle: Mapped[Optional[str]] = mapped_column(Text)
    observaciones: Mapped[Optional[str]] = mapped_column(Text)
    
    # Relación a Pedidos (para traer datos del pedido)
    pedido: Mapped[Optional["PedidoORM"]] = relationship(backref="ops")
    
    # Relación a Lotes (para la restricción de eliminación)
    lotes: Mapped[list["LoteORM"]] = relationship(backref="op", lazy="joined")



class LoteORM(Base):
    __tablename__ = "lotes"
    
    lote_id: Mapped[int] = mapped_column(primary_key=True)
    op_id: Mapped[int] = mapped_column(ForeignKey("op.op_id"))
    
    # No necesitamos más campos por ahora


# ProductosORM

class ProductoORM(Base):
    __tablename__ = "productos"
    producto_id: Mapped[int] = mapped_column(primary_key=True)
    nombre: Mapped[str] = mapped_column(String(100), unique=True)
    # Se puede agregar SKU, descripción, etc., si es necesario.


# ... Puestos de trabajos ORM -----

class PuestoTrabajoORM(Base):
    __tablename__ = "puestos_trabajo"
    puesto_trabajo_id: Mapped[int] = mapped_column(primary_key=True)
    nombre: Mapped[str] = mapped_column(String(100), unique=True)
    # CLAVE: Añadir el campo 'descripcion' (asumimos que puede ser opcional/Text)
    descripcion: Mapped[Optional[str]] = mapped_column(Text)



# backend/main.py - Sección MODELOS ORM

# A. Modelo de Encabezado (Rutas Maestras)
class RutaMaestraORM(Base):
    __tablename__ = "rutas_maestras"
    
    ruta_id: Mapped[int] = mapped_column(primary_key=True)
    nombre_ruta: Mapped[str] = mapped_column(String(100), unique=True)
    
    # CLAVE: Clave Foránea a Producto
    producto_id: Mapped[int] = mapped_column(ForeignKey("productos.producto_id"))
    
    # Relaciones
    producto: Mapped["ProductoORM"] = relationship()
    
    # Relación a los Pasos de la ruta (Detalle)
    pasos: Mapped[list["RutaDetalleORM"]] = relationship(
        back_populates="ruta_maestra", 
        order_by="RutaDetalleORM.secuencia" # Los pasos deben cargarse en el orden correcto
    )

# B. Modelo de Detalle (Rutas Detalle - Pasos)
class RutaDetalleORM(Base):
    __tablename__ = "rutas_detalle"
    
    detalle_id: Mapped[int] = mapped_column(primary_key=True)
    
    # Clave Foránea a la Ruta Maestra
    ruta_id: Mapped[int] = mapped_column(ForeignKey("rutas_maestras.ruta_id"))
    
    # Clave Foránea al Puesto de Trabajo
    puesto_id: Mapped[int] = mapped_column(ForeignKey("puestos_trabajo.puesto_trabajo_id"))
    
    secuencia: Mapped[int] = mapped_column() # Posición del paso en la ruta
    
    # Relaciones de vuelta
    ruta_maestra: Mapped["RutaMaestraORM"] = relationship(back_populates="pasos")
    puesto_trabajo: Mapped["PuestoTrabajoORM"] = relationship()



# --- LÓGICA DE NEGOCIO (Generación de Números Transaccional) -------------------------------------------------------------------------

async def generar_siguiente_numero(session: AsyncSession, tipo: str) -> Optional[str]:
    """
    Gestiona la transacción segura para incrementar el contador.
    Bloquea la fila para evitar que dos usuarios generen el mismo número.
    """
    try:
        # 1. Selecciona el valor actual y BLOQUEA la fila (FOR UPDATE)
        # Se usa getattr para acceder a la columna dinámicamente ('ultimo_pedido' o 'ultima_op')
        stmt = select(getattr(Numerador, tipo)).where(Numerador.id == 1).with_for_update()
        result = await session.execute(stmt)
        ultimo_numero = result.scalar_one_or_none()
        
        if ultimo_numero is None:
            await session.rollback()
            return None 

        nuevo_numero_int = ultimo_numero + 1
        
        # 2. Actualizar el contador con el nuevo valor
        update_stmt = (
            update(Numerador)
            .where(Numerador.id == 1)
            .values({tipo: nuevo_numero_int})
        )
        await session.execute(update_stmt)
        
        # 3. Formatear el número (Ej: 1 -> "P-000001")
        prefijo = "P" if tipo == 'ultimo_pedido' else "OP"
        numero_formateado = f"{prefijo}-{nuevo_numero_int:06}" # 6 dígitos, ej: 000001
        
        # 4. Confirma la transacción (liberando el bloqueo)
        await session.commit()
        
        return numero_formateado

    except Exception as e:
        await session.rollback()
        raise e




# --- INICIALIZACIÓN Y ENDPOINTS DE FASTAPI ------------------------------------------------------------------------

app = FastAPI(title="Backend Sistema de Producción")

@app.get("/")
def read_root():
    return {"message": "Sistema de Producción - Backend Activo"}

@app.get("/test-db-connection")
async def test_db_connection():
    """Endpoint para verificar que la conexión a la DB funcione."""
    try:
        # Ejecuta una consulta simple usando el motor de conexión
        async with engine.connect() as connection:
            result = await connection.execute(text("SELECT 1"))
            await connection.commit()
            
            if result.scalar_one() == 1:
                return {"status": "success", "message": "Conexión a PostgreSQL exitosa."}

    except Exception as e:
        return {"status": "error", "message": f"Fallo al conectar a DB: {str(e)}"}

@app.post("/pedidos/generar-numero")
async def generar_numero_pedido_endpoint(
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Genera y reserva el siguiente número de pedido único.
    """
    try:
        nuevo_numero = await generar_siguiente_numero(db_session, "ultimo_pedido")
        
        if nuevo_numero:
            return {"status": "success", "numero_pedido": nuevo_numero}
        else:
            return {"status": "error", "message": "No se pudo generar el número."}
    except Exception as e:
        return {"status": "error", "message": f"Error transaccional: {e}"}
        

# --- ENDPOINTS CRUD DE CLIENTES ---


# ENDPOINT: CREATE (Crear Nuevo Cliente)
@app.post("/clientes/", response_model=Cliente)
async def create_cliente(
    cliente_data: ClienteCreate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Crea un nuevo cliente en la base de datos."""
    db_cliente = ClienteORM(**cliente_data.model_dump())
    
    db_session.add(db_cliente)
    await db_session.commit()
    await db_session.refresh(db_cliente) # Obtiene el ID generado
    
    return db_cliente

@app.get("/clientes/", response_model=PaginatedClientes)
async def read_clientes(
    skip: int = 0, # Número de registros a omitir (offset)
    limit: int = 50, # Cantidad máxima de registros a devolver (page size)
    search: Optional[str] = None, # Término de búsqueda (por nombre, etc.)
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Obtiene clientes con soporte para paginación y filtrado. 
    Límite máximo de 100 registros.
    """
    
    # 1. Definir la consulta base (filtrado)
    query = select(ClienteORM)
    
    if search:
        # Añade la condición de filtrado: busca la coincidencia parcial en nombre
        # ILIKE es la forma de PostgreSQL de hacer búsqueda parcial insensible a mayúsculas
        query = query.where(ClienteORM.nombre.ilike(f"%{search}%"))

    # 2. Conteo total de registros (con filtro aplicado)
    # Contamos la cantidad de resultados que arrojaría la consulta ANTES de paginar
    count_stmt = select(func.count()).select_from(query.subquery())
    total_registros = (await db_session.execute(count_stmt)).scalar_one()

    # 3. Aplicar Paginación
    # Aseguramos un límite máximo para evitar abusos
    limit = min(limit, 100) 
    
    query = query.offset(skip).limit(limit)
    
    # 4. Ejecutar la consulta final
    result = await db_session.execute(query)
    clientes = result.scalars().all()
    
    # 5. Formatear la respuesta
    return PaginatedClientes(
        total_registros=total_registros,
        clientes=clientes,
        pagina_actual=int(skip/limit) if limit else 0, # Calculo simple de página
        tamanio_pagina=limit
    )

# ENDPOINT: READ (Obtener Cliente por ID)
@app.get("/clientes/{cliente_id}", response_model=Cliente)
async def read_cliente(cliente_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene un cliente específico por su ID."""
    result = await db_session.execute(
        select(ClienteORM).where(ClienteORM.cliente_id == cliente_id)
    )
    cliente = result.scalar_one_or_none()
    
    if cliente is None:
        raise HTTPException(status_code=404, detail="Cliente no encontrado")
        
    return cliente


# --- ENDPOINTS CRUD DE PEDIDOS ---

# ENDPOINT: CREATE (Crear Nuevo Pedido)
@app.post("/pedidos/", response_model=Pedido)
async def create_pedido(
    pedido_data: PedidoCreate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Crea un nuevo pedido. Requiere primero generar un número externo único
    usando la lógica transaccional del numerador.
    """
    # 1. GENERAR EL NÚMERO DE PEDIDO EXTERNO (Lógica crítica)
    try:
        # La función genera el número, lo actualiza en la tabla numeradores y hace commit
        numero_externo = await generar_siguiente_numero(db_session, "ultimo_pedido")
        
        if not numero_externo:
            raise HTTPException(status_code=500, detail="Fallo al generar número de pedido.")

    except Exception as e:
        # El rollback ya ocurre dentro de generar_siguiente_numero, solo lanzamos la excepción
        raise HTTPException(status_code=500, detail=f"Error en transacción del numerador: {str(e)}")


    # 2. VERIFICAR QUE EL CLIENTE EXISTA (Integridad de la clave foránea)
    cliente_existe = await db_session.execute(
        select(ClienteORM).where(ClienteORM.cliente_id == pedido_data.cliente_id)
    )
    if cliente_existe.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail=f"Cliente con ID {pedido_data.cliente_id} no encontrado.")
        
        
    # 3. CREAR EL REGISTRO EN LA TABLA PEDIDOS
    
    # 3.1. CONSTRUIR EL DICCIONARIO DE DATOS (Soluciona el NameError)
    pedido_dict = pedido_data.model_dump()
    
    # 3.2. Añadir el número generado externamente
    pedido_dict["numero_pedido_externo"] = numero_externo
    
    # 3.3. Crear la instancia de PedidoORM
    db_pedido = PedidoORM(**pedido_dict)
    
    db_session.add(db_pedido)
    
    # Commit final del pedido (Guarda el registro en la DB y genera pedido_id)
    await db_session.commit()
    
    # === CARGA ANSIOSA Y EXPUNGE PARA EVITAR MissingGreenlet ===
    
    # 4. Recargar el objeto con la relación 'cliente' cargada ansiosamente
    # Esto es necesario porque el objeto db_pedido original no cargó la relación.
    loaded_pedido = await db_session.execute(
        select(PedidoORM)
        .where(PedidoORM.pedido_id == db_pedido.pedido_id)
        .options(selectinload(PedidoORM.cliente)) # <--- Carga el cliente
    )
    # Usamos scalar_one() porque sabemos que el registro existe
    db_pedido_loaded = loaded_pedido.scalar_one()

    # 5. Expunge: Libera el objeto de la sesión.
    db_session.expunge(db_pedido_loaded)
    
    # Retornamos el objeto cargado.
    return db_pedido_loaded


# ENDPOINT: READ (Obtener Todos los Pedidos con Paginación, Filtrado Y DATOS DE CLIENTE)
@app.get("/pedidos/", response_model=PaginatedPedidos)
async def read_pedidos(
    skip: int = 0, 
    limit: int = 50, 
    search: Optional[str] = None,
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Obtiene pedidos con soporte para paginación y filtrado, incluyendo 
    los datos del cliente en la misma consulta (selectinload).
    """
    
    # 1. Definir la consulta base y la precarga del cliente
    # CLAVE: Usamos selectinload para cargar la relación 'cliente' eficientemente
    query = select(PedidoORM).options(selectinload(PedidoORM.cliente))
    
    if search:
        # Añade la condición de filtrado
        query = query.where(
            (PedidoORM.numero_pedido_externo.ilike(f"%{search}%")) |
            (PedidoORM.detalle.ilike(f"%{search}%"))
        )

    # 2. Conteo total de registros (con filtro aplicado)
    count_stmt = select(func.count()).select_from(query.subquery())
    total_registros = (await db_session.execute(count_stmt)).scalar_one()

    # 3. Aplicar Paginación
    limit = min(limit, 100)
    query = query.offset(skip).limit(limit)
    
    # 4. Ejecutar la consulta final
    result = await db_session.execute(query)
    pedidos = result.scalars().unique().all() # Usamos .unique() para evitar duplicados si hay JOINs

    # 5. Formatear la respuesta
    return PaginatedPedidos(
        total_registros=total_registros,
        pedidos=pedidos,
        pagina_actual=int(skip/limit) if limit else 0,
        tamanio_pagina=limit
    )

# ENDPOINT: READ (Obtener un Pedido por ID con Datos de Cliente)
@app.get("/pedidos/{pedido_id}", response_model=Pedido)
async def read_pedido(pedido_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene un pedido específico por su ID, incluyendo datos del cliente."""
    
    # Busca el pedido por ID y carga la relación 'cliente'
    result = await db_session.execute(
        select(PedidoORM)
        .where(PedidoORM.pedido_id == pedido_id)
        .options(selectinload(PedidoORM.cliente))
    )
    db_pedido = result.scalar_one_or_none()
    
    if db_pedido is None:
        raise HTTPException(status_code=404, detail="Pedido no encontrado")
        
    return db_pedido

# ENDPOINT: UPDATE (Modificar Pedido)
@app.put("/pedidos/{pedido_id}", response_model=Pedido)
async def update_pedido(
    pedido_id: int,
    pedido_data: PedidoUpdate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Modifica los campos editables de un pedido existente."""
    
    # Obtener el pedido existente
    result = await db_session.execute(
        select(PedidoORM).where(PedidoORM.pedido_id == pedido_id)
    )
    db_pedido = result.scalar_one_or_none()
    
    if db_pedido is None:
        raise HTTPException(status_code=404, detail="Pedido no encontrado")

    # Obtener solo los campos que no son None en el input de Pydantic
    update_data = pedido_data.model_dump(exclude_unset=True)
    
    # Aplicar los cambios al objeto ORM
    for key, value in update_data.items():
        setattr(db_pedido, key, value)
        
    await db_session.commit()
    await db_session.refresh(db_pedido)
    
    return db_pedido

# ENDPOINT: DELETE (Eliminar Pedido - Con Restricción de OP)
@app.delete("/pedidos/{pedido_id}", status_code=204)
async def delete_pedido(
    pedido_id: int,
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Elimina un pedido solo si no tiene Órdenes de Producción (OP) asignadas.
    """
    
    # 1. VERIFICAR SI EXISTEN ÓRDENES DE PRODUCCIÓN ASIGNADAS
    # Usamos el modelo OpORM para buscar
    op_asignada = await db_session.execute(
        select(OpORM).where(OpORM.pedido_id == pedido_id)
    )
    
    # Si encuentra al menos una OP, lanza una excepción
    if op_asignada.first():
        raise HTTPException(
            status_code=400, 
            detail="No se puede eliminar el pedido. Tiene Órdenes de Producción (OP) asignadas."
        )

    # 2. INTENTAR ELIMINAR EL PEDIDO
    # Se usa la sentencia delete de SQLAlchemy para un borrado directo
    result = await db_session.execute(
        delete(PedidoORM).where(PedidoORM.pedido_id == pedido_id).returning(PedidoORM.pedido_id)
    )
    
    # Si result.scalar_one_or_none() es None, significa que no se encontró el ID
    if result.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail="Pedido no encontrado")
        
    await db_session.commit()
    
    # Respuesta 204 indica éxito sin contenido
    return 

# backend/main.py - Sección ENDPOINTS FASTAPI

# ... después del CRUD de Pedidos ...

# ENDPOINT: CREATE (Crear Nueva Orden de Producción)
@app.post("/op/", response_model=OP)
async def create_op(
    op_data: OPCreate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Crea una nueva Orden de Producción (OP).
    Genera el número externo y verifica si el pedido asociado existe.
    """
    
    # 1. GENERAR EL NÚMERO DE OP EXTERNO
    try:
        numero_externo = await generar_siguiente_numero(db_session, "ultima_op")
        if not numero_externo:
            raise HTTPException(status_code=500, detail="Fallo al generar número de OP.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error en transacción del numerador: {str(e)}")

    # 2. VERIFICAR QUE EL PEDIDO EXISTA (si se proporcionó)
    if op_data.pedido_id is not None:
        pedido_existe = await db_session.execute(
            select(PedidoORM).where(PedidoORM.pedido_id == op_data.pedido_id)
        )
        if pedido_existe.scalar_one_or_none() is None:
            raise HTTPException(status_code=404, detail=f"Pedido con ID {op_data.pedido_id} no encontrado.")

    # 3. CREAR EL REGISTRO EN LA TABLA OP
    op_dict = op_data.model_dump()
    op_dict["numero_op_externo"] = numero_externo

    db_op = OpORM(**op_dict)
    db_session.add(db_op)
    await db_session.commit()
    
    # 4. CARGA ANSIOSA Y EXPUNGE (para evitar MissingGreenlet al retornar)
    loaded_op = await db_session.execute(
        select(OpORM)
        .where(OpORM.op_id == db_op.op_id)
        .options(selectinload(OpORM.pedido)) # Cargamos el Pedido, no necesitamos el Cliente aquí
    )
    db_op_loaded = loaded_op.scalar_one()
    db_session.expunge(db_op_loaded)
    
    return db_op_loaded


# ENDPOINT: READ (Obtener todas las OP con Paginación y Filtrado)
@app.get("/op/", response_model=PaginatedOP)
async def read_ops(
    skip: int = 0, 
    limit: int = 50, 
    search: Optional[str] = None,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Obtiene OP con paginación, filtrado y datos de Pedido/Cliente."""
    
    # Carga el Pedido y el Cliente del Pedido en una sola consulta
    query = select(OpORM).options(
        selectinload(OpORM.pedido).selectinload(PedidoORM.cliente)
    )
    
    if search:
        query = query.where(
            (OpORM.numero_op_externo.ilike(f"%{search}%")) |
            (OpORM.detalle.ilike(f"%{search}%"))
        )

    count_stmt = select(func.count()).select_from(query.subquery())
    total_registros = (await db_session.execute(count_stmt)).scalar_one()

    limit = min(limit, 100)
    query = query.offset(skip).limit(limit)
    
    result = await db_session.execute(query)
    ops = result.scalars().unique().all()
    
    return PaginatedOP(
        total_registros=total_registros,
        ops=ops,
        pagina_actual=int(skip/limit) if limit else 0,
        tamanio_pagina=limit
    )

# ENDPOINT: READ (Obtener una OP por ID)
@app.get("/op/{op_id}", response_model=OP)
async def read_op(op_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene una OP específica por su ID."""
    result = await db_session.execute(
        select(OpORM)
        .where(OpORM.op_id == op_id)
        .options(selectinload(OpORM.pedido).selectinload(PedidoORM.cliente))
    )
    db_op = result.scalar_one_or_none()
    
    if db_op is None:
        raise HTTPException(status_code=404, detail="Orden de Producción no encontrada")
        
    return db_op


# ENDPOINT: UPDATE (Modificar OP)
@app.put("/op/{op_id}", response_model=OP)
async def update_op(
    op_id: int,
    op_data: OPUpdate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Modifica los campos editables de una OP existente."""
    result = await db_session.execute(
        select(OpORM).where(OpORM.op_id == op_id)
    )
    db_op = result.scalar_one_or_none()
    
    if db_op is None:
        raise HTTPException(status_code=404, detail="OP no encontrada")

    update_data = op_data.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_op, key, value)
        
    await db_session.commit()
    await db_session.refresh(db_op)
    
    return db_op

# ENDPOINT: DELETE (Eliminar OP - Con Restricción de Lotes)
@app.delete("/op/{op_id}", status_code=204)
async def delete_op(
    op_id: int,
    db_session: AsyncSession = Depends(get_db_session)
):
    """
    Elimina una OP solo si no tiene Lotes asignados.
    """
    
    # 1. VERIFICAR SI EXISTEN LOTES ASIGNADOS
    lote_asignado = await db_session.execute(
        select(LoteORM).where(LoteORM.op_id == op_id)
    )
    
    if lote_asignado.first():
        raise HTTPException(
            status_code=400, 
            detail="No se puede eliminar la OP. Tiene Lotes de Producción asignados."
        )

    # 2. INTENTAR ELIMINAR LA OP
    result = await db_session.execute(
        delete(OpORM).where(OpORM.op_id == op_id).returning(OpORM.op_id)
    )
    
    if result.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail="OP no encontrada")
        
    await db_session.commit()
    return


# backend/main.py - Sección ENDPOINTS CRUD DE PRODUCTOS

# ENDPOINT: CREATE (Crear Producto)
@app.post("/productos/", response_model=Producto)
async def create_producto(
    producto_data: ProductoCreate, 
    db_session: AsyncSession = Depends(get_db_session)
):
    """Crea un nuevo producto."""
    db_producto = ProductoORM(**producto_data.model_dump())
    db_session.add(db_producto)
    
    try:
        await db_session.commit()
        await db_session.refresh(db_producto)
    except Exception as e:
        # Manejo de error si el nombre ya existe (Unique Constraint)
        raise HTTPException(status_code=400, detail="El nombre del producto ya existe o es inválido.")

    return db_producto

# ENDPOINT: READ ALL (Obtener todos los Productos)
@app.get("/productos/", response_model=list[Producto])
async def read_productos(db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene una lista de todos los productos (lista simple, no paginada)."""
    result = await db_session.execute(select(ProductoORM).order_by(ProductoORM.nombre))
    return result.scalars().all()

# ENDPOINT: READ BY ID (Obtener Producto por ID)
@app.get("/productos/{producto_id}", response_model=Producto)
async def read_producto(producto_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene un producto específico por su ID."""
    result = await db_session.execute(select(ProductoORM).where(ProductoORM.producto_id == producto_id))
    db_producto = result.scalar_one_or_none()
    
    if db_producto is None:
        raise HTTPException(status_code=404, detail="Producto no encontrado")
    return db_producto

# ENDPOINT: DELETE (Eliminar Producto)
@app.delete("/productos/{producto_id}", status_code=204)
async def delete_producto(producto_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Elimina un producto. Fallará si tiene Lotes u otras referencias activas."""
    
    result = await db_session.execute(
        delete(ProductoORM).where(ProductoORM.producto_id == producto_id).returning(ProductoORM.producto_id)
    )
    
    if result.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail="Producto no encontrado")
        
    try:
        await db_session.commit()
    except Exception as e:
        # Esto captura el error si el producto está siendo referenciado por un Lote
        raise HTTPException(status_code=400, detail="No se puede eliminar. El producto está siendo usado por uno o más lotes.")
        
    return



# backend/main.py - Sección ENDPOINTS CRUD DE PUESTOS DE TRABAJO

# ENDPOINT: CREATE (Crear Puesto de Trabajo)
@app.post("/puestos-trabajo/", response_model=PuestoTrabajo)
async def create_puesto_trabajo(
    puesto_data: PuestoTrabajoCreate, 
    db_session: AsyncSession = Depends(get_db_session)
):
    """Crea un nuevo puesto de trabajo."""
    db_puesto = PuestoTrabajoORM(**puesto_data.model_dump())
    db_session.add(db_puesto)
    
    try:
        await db_session.commit()
        await db_session.refresh(db_puesto)
    except Exception as e:
        raise HTTPException(status_code=400, detail="El nombre del puesto de trabajo ya existe o es inválido.")

    return db_puesto

# ENDPOINT: READ ALL (Obtener todos los Puestos de Trabajo)
@app.get("/puestos-trabajo/", response_model=list[PuestoTrabajo])
async def read_puestos_trabajo(db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene una lista de todos los puestos de trabajo."""
    result = await db_session.execute(select(PuestoTrabajoORM).order_by(PuestoTrabajoORM.nombre))
    return result.scalars().all()

# ENDPOINT: READ BY ID (Obtener Puesto de Trabajo por ID)
@app.get("/puestos-trabajo/{puesto_id}", response_model=PuestoTrabajo)
async def read_puesto_trabajo(puesto_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene un puesto de trabajo específico por su ID."""
    result = await db_session.execute(select(PuestoTrabajoORM).where(PuestoTrabajoORM.puesto_trabajo_id == puesto_id))
    db_puesto = result.scalar_one_or_none()
    
    if db_puesto is None:
        raise HTTPException(status_code=404, detail="Puesto de Trabajo no encontrado")
    return db_puesto

# backend/main.py - Sección ENDPOINTS CRUD DE PUESTOS DE TRABAJO

# ENDPOINT: UPDATE (Modificar Puesto de Trabajo)
@app.put("/puestos-trabajo/{puesto_id}", response_model=PuestoTrabajo)
async def update_puesto_trabajo(
    puesto_id: int,
    puesto_data: PuestoTrabajoUpdate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Modifica el nombre y/o la descripción de un puesto de trabajo existente."""
    
    # 1. Buscar el puesto de trabajo
    result = await db_session.execute(
        select(PuestoTrabajoORM).where(PuestoTrabajoORM.puesto_trabajo_id == puesto_id)
    )
    db_puesto = result.scalar_one_or_none()
    
    if db_puesto is None:
        raise HTTPException(status_code=404, detail="Puesto de Trabajo no encontrado")

    # 2. Obtener solo los campos que se enviaron (no None)
    update_data = puesto_data.model_dump(exclude_unset=True)
    
    # 3. Aplicar los cambios al objeto ORM
    for key, value in update_data.items():
        setattr(db_puesto, key, value)
        
    try:
        await db_session.commit()
        await db_session.refresh(db_puesto)
    except Exception as e:
        # Captura si el nuevo nombre ya existe
        raise HTTPException(status_code=400, detail="Error al actualizar. El nombre ya está en uso.")

    return db_puesto

# ENDPOINT: DELETE (Eliminar Puesto de Trabajo)
@app.delete("/puestos-trabajo/{puesto_id}", status_code=204)
async def delete_puesto_trabajo(puesto_id: int, db_session: AsyncSession = Depends(get_db_session)):
    """Elimina un puesto de trabajo. Fallará si tiene referencias en Movimientos."""
    
    result = await db_session.execute(
        delete(PuestoTrabajoORM).where(PuestoTrabajoORM.puesto_trabajo_id == puesto_id).returning(PuestoTrabajoORM.puesto_trabajo_id)
    )
    
    if result.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail="Puesto de Trabajo no encontrado")
        
    try:
        await db_session.commit()
    except Exception as e:
        raise HTTPException(status_code=400, detail="No se puede eliminar. El puesto de trabajo tiene movimientos asociados.")
        
    return

# backend/main.py - Sección ENDPOINTS CRUD DE RUTAS



# ENDPOINT: CREATE (Crear Ruta Maestra con sus Pasos Detalle)
@app.post("/rutas/", response_model=RutaMaestra, status_code=status.HTTP_201_CREATED)
async def create_ruta_maestra(
    ruta_data: RutaMaestraCreate,
    db_session: AsyncSession = Depends(get_db_session)
):
    """Crea una Ruta Maestra para un producto y sus Pasos Detalle asociados."""
    
    # 1. Verificar existencia de Producto y Puestos de Trabajo (Mínimo requerido)
    
    # Verificar Producto
    producto_existe = await db_session.execute(
        select(ProductoORM).where(ProductoORM.producto_id == ruta_data.producto_id)
    )
    if producto_existe.scalar_one_or_none() is None:
        raise HTTPException(status_code=404, detail="Producto no encontrado.")

    # Verificar que todos los Puestos de Trabajo en los pasos existan
    puesto_ids = {paso.puesto_id for paso in ruta_data.pasos}
    if puesto_ids:
        puestos_count = await db_session.execute(
            select(func.count(PuestoTrabajoORM.puesto_trabajo_id))
            .where(PuestoTrabajoORM.puesto_trabajo_id.in_(puesto_ids))
        )
        if puestos_count.scalar_one() != len(puesto_ids):
             raise HTTPException(status_code=404, detail="Uno o más Puestos de Trabajo en los pasos no existen.")


    # 2. Crear la Ruta Maestra
    db_ruta = RutaMaestraORM(
        nombre_ruta=ruta_data.nombre_ruta,
        producto_id=ruta_data.producto_id
    )
    db_session.add(db_ruta)
    await db_session.flush() 
    
    # 3. Crear los Pasos Detalle asociados
    for paso_data in ruta_data.pasos:
        db_paso = RutaDetalleORM(
            ruta_id=db_ruta.ruta_id,
            puesto_id=paso_data.puesto_id,
            secuencia=paso_data.secuencia
        )
        db_session.add(db_paso)
        
    try:
        await db_session.commit()
    except Exception as e:
        # Esto captura el error si el nombre de la ruta ya existe
        await db_session.rollback()
        raise HTTPException(status_code=400, detail="El nombre de la ruta ya existe o hay un error de datos.")

    # 4. Recargar y devolver la ruta completa con todas las relaciones cargadas
    result = await db_session.execute(
        select(RutaMaestraORM)
        .where(RutaMaestraORM.ruta_id == db_ruta.ruta_id)
        .options(
            joinedload(RutaMaestraORM.producto),
            joinedload(RutaMaestraORM.pasos).joinedload(RutaDetalleORM.puesto_trabajo)
        )
    )
    return result.unique().scalar_one()

# ENDPOINT: READ ALL (Obtener todas las Rutas con sus Pasos y relaciones)
@app.get("/rutas/", response_model=list[RutaMaestra])
async def read_rutas_maestras(db_session: AsyncSession = Depends(get_db_session)):
    """Obtiene todas las Rutas Maestras con sus Pasos, Producto y Puestos de Trabajo anidados."""
    result = await db_session.execute(
        select(RutaMaestraORM)
        .options(
            joinedload(RutaMaestraORM.producto),
            joinedload(RutaMaestraORM.pasos).joinedload(RutaDetalleORM.puesto_trabajo)
        )
    )
    return result.scalars().unique().all()